<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>gobang</title>
    <script>
        /**
         * @brief 全局初始化函数
         * @param 无
         * @retval 无
        */
        window.onload = function()
        {
            let ui = new UI(true,6);
            let canvas = document.getElementById('chessboard');
            //-- canvas点击触发事件
            canvas.onclick = function(e)
            {
                let act_x = Math.floor((e.offsetX-20)/40)+((e.offsetX-20)%40>=20?1:0);
                let act_y = Math.floor((e.offsetY-20)/40)+((e.offsetY-20)%40>=20?1:0);
                
                if(!ui.chessboard[act_x][act_y]&&!ui.win)
                {
                    ui.toSetOnePiece(act_x,act_y,true);
                    ui.chessboard[act_x][act_y] = 1;
                    if(ui.toCheckWin(ui.chessboard))
                    {
                        ui.win = true;
                        return;
                    }
                    //-- 使得白方落子后（AI）再计算下一步效果更明显
                    setTimeout(()=>
                    {
                        let res = ui.ai.toGiveResponse(act_x,act_y);
                        if(res[0]!=-1&&res[1]!=-1)
                        {
                            ui.toSetOnePiece(res[0],res[1]);
                            ui.chessboard[res[0]][res[1]] = -1;
                        }
                        if(ui.toCheckWin(ui.chessboard))
                        {
                            ui.win = true;
                            return;
                        }
                    },10);
                    
                }
                
            }
        }

        /**
         * @brief AI类
         * @param 无
         * @retval 无
        */
        class AI
        {
            /**
             * @brief AI类构造函数
             * @param 无
             * @retval 无
            */
            constructor(isFirst,depth)
            {
                //-- 棋盘尺寸
                this.boardSize = 15;
                //-- 棋局状态储存数组 
                this.pieces = new Array();
                for(let i=0;i<this.boardSize;i++)
                {
                    this.pieces[i] = new Array();
                    for(let j=0;j<this.boardSize;j++)
                    {
                        this.pieces[i][j] = 0;
                    }
                }
                //-- 定义无穷
                this.INF = 9999999;
                //-- 搜索深度
                this.depth = depth;
                //-- 是否先手
                this.init = [-1,-1];
                if(isFirst)
                {
                    this.init = this.toGiveResponse(-1,-1);
                }
            }

            /**
             * @brief 棋局评估函数
             * @param 棋局存储（二维）数组
             * @retval 棋局分数（越高越有利于AI）
            */
            toEvaluate(pieces)
            {
               let resScore = 0;
               //-- 四个方向共六轮(斜方向上下部分各算一轮)
               for(let r=0;r<6;r++)
               {
                   //-- 等效行
                   for(let i=0;i<this.boardSize;i++)
                   {
                       //-- 兼容斜方向
                       if((r==3||r==5)&&i==0)
                       {
                            continue;
                        }
                        else
                        {
                            //-- 一系列标记声明
                            let flagLeft = false;// 左标记
                            let flagRight = false;// 右标记
                            let flagWhich = 0;// 当前（计数器）记录棋种标记
                            let count = 0;// 计数器
                            //-- 等效列
                            for(let j=0;j<this.boardSize;j++)
                            {
                                let posX = (r==0?i:(r==1||r==2?j:(r==3?i+j:(r==4?i-j:14-j))));
                                let posY = (r==0?j:(r==1?i:(r==2?14-i+j:(r==3||r==4?j:i+j))));
                                //-- 兼容斜方向
                                if(posX>this.boardSize-1||posX<0||posY>this.boardSize-1||posY<0)
                                {
                                    break;
                                }
                                else
                                {
                                    //-- 得到当前棋子
                                    let thisPiece = pieces[posX][posY];

                                    //-- 根据flagWhich进行决策
                                    if(thisPiece==flagWhich)
                                    {
                                        if(flagWhich!=0)
                                        {
                                            count++;
                                        }
                                    }
                                    else if(flagWhich==0)
                                    {
                                        if(j==0)
                                        {
                                            flagWhich = thisPiece;
                                            flagLeft = true;
                                            count++;
                                        }
                                        else
                                        {
                                            flagWhich = thisPiece;
                                            flagLeft = false;
                                            count++;
                                        }
                                    }
                                    else
                                    {
                                        //-- 否则进行算分（只是4算分）
                                        if(thisPiece==0)
                                        {
                                            flagRight = false;
                                        }
                                        else
                                        {
                                            flagRight = true;
                                        }
                                        resScore += (flagWhich==-1?1:-1)*Math.pow(10,((flagLeft&&flagRight)?(count>=5?count:0):((!flagLeft&&!flagRight)?count:(count>=5?count:count-1))));
                                        //-- 状态转移
                                        flagWhich = thisPiece;
                                        flagLeft = thisPiece==0?false:true;
                                        count = 0;
                                        count += thisPiece==0?0:1; 
                                    }
                                }
                            }
                            //-- 处理等效列最后
                            if(flagWhich)
                            {
                                flagRight = true;
                                resScore += (flagWhich==-1?1:-1)*Math.pow(10,(flagLeft&&flagRight?(count>=5?count:0):(!flagLeft&&!flagRight?count:(count>=5?count:count-1))));
                            }
                        }
                    }
                }
                //-- 返回
                return resScore;
            }
            
            /**
             * @brief 判断某特定位置是否孤立（两步步长内皆不存在棋子）
             * @param 棋局存储数组、位置纵坐标（行）、位置横坐标（列）
             * @retval true（孤立）/false（不孤立）
            */
            toJudgeIsland(pieces,x,y)
            {
                for(let i=0;i<3;i++)
                {
                    for(let j=0;j<3;j++)
                    {
                        let posX = x-1+i;
                        let posY = y-1+j;
                        if(posX<=this.boardSize-1&&posX>=0&&posY<=this.boardSize-1&&posY>=0)
                        {
                            if(pieces[posX][posY])
                            {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            /**
             * @brief 从所有空闲位置中找出非孤立位置，并将位置按落子后可得分数的高/低进行排序
             * @param 棋局存储数组、落子类型标志
             * @retval 已排序待选位置的二维数组（可得分数、行、列）
            */
            toGetPostionsOrdered(pieces,flagWhich)
            {
                //-- 待选位置数组初始化
                let resPos = new Array();             
                //-- 为位置数组赋初值
                for(let i=0;i<this.boardSize;i++)
                {
                    for(let j=0;j<this.boardSize;j++)
                    {
                        if(!pieces[i][j])
                        {
                            if(!this.toJudgeIsland(pieces,i,j))
                            {
                                let tmpPieces = new Array();
                                for(let k=0;k<pieces.length;k++)
                                {
                                    tmpPieces[k] = pieces[k].concat();
                                }

                                tmpPieces[i][j] = flagWhich?1:-1;
                                resPos.push([this.toEvaluate(tmpPieces),i,j]);
                            }
                        }
                    }
                }
                //-- 将位置数组排序（冒泡，依据落子类型标志）
                for(let i=0;i<resPos.length;i++)
                {
                    for(let j=0;j<resPos.length-i-1;j++)
                    {
                        if(flagWhich?(resPos[j][0]>resPos[j+1][0]):(resPos[j][0]<resPos[j+1][0]))
                        {
                            let tmpScore = resPos[j][0];
                            let tmpX = resPos[j][1];
                            let tmpY = resPos[j][2];
                            resPos[j][0] = resPos[j+1][0];
                            resPos[j][1] = resPos[j+1][1];
                            resPos[j][2] = resPos[j+1][2];
                            resPos[j+1][0] = tmpScore;
                            resPos[j+1][1] = tmpX;
                            resPos[j+1][2] = tmpY;
                        }
                    }
                }
                return resPos.slice(0,resPos.length>=30?Math.floor(resPos.length/3):(resPos.length>=20?Math.floor(resPos.length/2):Math.floor(resPos.length)));
            }
            
            /**
             * @brief 从所有待选位置中选出极值
             * @param 待选位置存储数组、极值判别标志（选极大还是极小）
             * @retval 极值位置
            */
            toFindExtremum(posPool,flagWhich)
            {
                let extremum = [flagWhich?this.INF:-this.INF,-1,-1];
                for(let i=0;i<posPool.length;i++)
                {
                    if(flagWhich?(posPool[i][0]<=extremum[0]):(posPool[i][0]>=extremum[0]))
                    {
                        extremum[0] = posPool[i][0];
                        extremum[1] = posPool[i][1];
                        extremum[2] = posPool[i][2];
                    }
                }
                return extremum;
            }

            toJudgeShouldWin(pieces,flag)
            {
                for(let r=0;r<6;r++)
                {
                    for(let i=0;i<this.boardSize;i++)
                    {
                        if((r==3||r==5)&&i==0)
                        {
                            continue;
                        }
                        else
                        {
                            let flagLeft = false;// 左标记
                            let flagRight = false;// 右标记
                            let flagWhich = 0;// 当前（计数器）记录棋种标记
                            let count = 0;// 计数器
                            //-- 等效列
                            for(let j=0;j<this.boardSize;j++)
                            {
                                let posX = (r==0?i:(r==1||r==2?j:(r==3?i+j:(r==4?i-j:14-j))));
                                let posY = (r==0?j:(r==1?i:(r==2?14-i+j:(r==3||r==4?j:i+j))));
                                //-- 兼容斜方向
                                if(posX>this.boardSize-1||posX<0||posY>this.boardSize-1||posY<0)
                                {
                                    break;
                                }
                                else
                                {
                                    //-- 得到当前棋子
                                    let thisPiece = pieces[posX][posY];
                                    //-- 根据flagWhich进行决策
                                    if(thisPiece==flagWhich)
                                    {
                                        if(flagWhich!=0)
                                        {
                                            count++;
                                        }
                                    }
                                    else if(flagWhich==0)
                                    {
                                        if(j==0)
                                        {
                                            flagWhich = thisPiece;
                                            flagLeft = true;
                                            count++;
                                        }
                                        else
                                        {
                                            flagWhich = thisPiece;
                                            flagLeft = false;
                                            count++;
                                        }
                                    }
                                    else
                                    {
                                        //-- 否则进行算分（只是单次算分）
                                        if(thisPiece==0)
                                        {
                                            flagRight = false;
                                        }
                                        else
                                        {
                                            flagRight = true;
                                        }
                                        if(flagWhich==flag)
                                        {
                                            if(count>=5)
                                            {
                                                return true;
                                            }
                                        }
                                        //-- 状态转移
                                        flagWhich = thisPiece;
                                        flagLeft = thisPiece==0?false:true;
                                        count = 0;
                                        count += thisPiece==0?0:1; 
                                    }
                                }
                            }
                            //-- 处理等效列最后
                            if(count>=5&&flagWhich==flag)
                            {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
        
            /**
             * @brief 搜索特定层数（递归），确定落点
             * @param 棋局存储数组、搜索深度、上层极值（用于ab剪枝）
             * @retval 落点（一个具体位置）
            */
            toChoosePos(pieces,depth,extremum)
            {
                if(depth>1)
                {
                    let posPool = new Array();
                    let candidate = this.toGetPostionsOrdered(pieces,depth%2);

                    for(let c of candidate)
                    {
                        let tmpPieces = new Array();
                        for(let k=0;k<pieces.length;k++)
                        {
                            tmpPieces[k] = pieces[k].concat();
                        }
                        tmpPieces[c[1]][c[2]] = depth%2?1:-1;
                        if(this.toJudgeShouldWin(tmpPieces,depth%2?1:-1)&&depth==this.depth)
                        {   
                            return [this.INF,c[1],c[2]];
                        }
                        else
                        {
                            let extremumInThePool = this.toFindExtremum(posPool,depth%2);
                            let tmpPos = this.toChoosePos(tmpPieces,depth-1,extremumInThePool[0]);
                            //-- 剪枝
                            if(depth%2?(tmpPos[0]<=extremum):(tmpPos[0]>=extremum))
                            {
                                return [tmpPos[0],c[1],c[2]];
                            }
                            else
                            {
                                posPool.push([tmpPos[0],c[1],c[2]]);
                            }
                        }   
                    }
                    //-- 返回当前层极值
                    return this.toFindExtremum(posPool,depth%2);
                }
                else
                {
                    let minPool = new Array();
                    for(let i=0;i<this.boardSize;i++)
                    {
                        for(let j=0;j<this.boardSize;j++)
                        {
                            if(!pieces[i][j])
                            {
                                if(!this.toJudgeIsland(pieces,i,j))
                                {
                                    let tmpPieces = new Array();
                                    for(let k=0;k<pieces.length;k++)
                                    {
                                        tmpPieces[k] = pieces[k].concat();
                                    }
                                    tmpPieces[i][j] = 1;
                                    let tmpScore = this.toEvaluate(tmpPieces);
                                    if(tmpScore<=extremum)
                                    {
                                        return [tmpScore,i,j];
                                    }
                                    else
                                    {
                                        minPool.push([tmpScore,i,j]);
                                    }
                                }
                            }
                        }
                    }
                    return this.toFindExtremum(minPool,true);
                }
            }
            
            /**
             * @brief 根据对手下棋位置作出回应
             * @param 对手落子位置
             * @retval 计算后决定的落子位置
            */
            toGiveResponse(x,y)
            {
                if(x==-1&&y==-1)
                {
                    // console.log(this.pieces);
                    this.pieces[7][7] = -1;
                    return [7,7];
                }
                else
                {
                    // console.log(this.pieces);
                    this.pieces[x][y] = 1;
                    let res = this.toChoosePos(this.pieces,this.depth,this.INF);
                    if(res[1]==-1||res[2]==-1)
                    {
                        console.log(res[0]);
                        alert('sth is wrong！');
                        return [-1,-1];
                    }
                    else
                    {
                        this.pieces[res[1]][res[2]] = -1;
                        return [res[1],res[2]];
                    }
                }
            }
        }

        /**
         * @brief 棋盘类
         * @param 无
         * @retval 无
        */
        class UI
        {
            /**
             * @brief 构造函数
             * @param 是否先手、搜索深度
             * @retval 无
            */
            constructor(isFirst,depth)
            {
                //-- 创建棋盘AI
                this.ai = new AI(isFirst,depth);

                //-- 棋盘初始化
                this.boardSize = this.ai.boardSize;

                //-- 本地数组（用以判断点击有效性：若该处有棋子则该次点击无效）
                this.chessboard = new Array();
                for(let i=0;i<this.boardSize;i++)
                {
                    this.chessboard[i] = new Array();
                    for(let j=0;j<this.boardSize;j++)
                    {
                        this.chessboard[i][j] = 0;
                    }
                }

                this.initHtml();
                this.initCanvas();
                this.drawChessboard();

                if(this.ai.init[0]!=-1&&this.ai.init[1]!=-1)
                {
                    this.toSetOnePiece(this.ai.init[0],this.ai.init[1],false);
                    this.chessboard[this.ai.init[1]][this.ai.init[1]] = -1;
                }

                this.win = false;
            }
            
            /**
             * @brief 绘制棋盘
             * @param 无
             * @retval 无
            */
            drawChessboard()
            {   
                let canvas = document.getElementById('chessboard');
                let ctx = canvas.getContext('2d');
                ctx.beginPath();
                ctx.lineWidth = '1';
                ctx.strokeStyle = 'black';
                ctx.font = 'normal normal lighter 10px Arial';
                for(let i=0;i<this.boardSize;i++)
                {
                    ctx.fillText(i+1,4,20+40*i);
                    ctx.moveTo(20,20+40*i);
                    ctx.lineTo(580,20+40*i);
                    ctx.fillText(String.fromCharCode(65+i),20+40*i,11);
                    ctx.moveTo(20+40*i,20);
                    ctx.lineTo(20+40*i,580);
                }
                ctx.stroke();
                ctx.closePath();            
            }

            /**
             * @brief 初始化页面
             * @param 无
             * @retval 无
            */
            initHtml()
            {
                let html = document.getElementsByTagName('html')[0];
                html.style.height = '100%';
                html.style.width = '100%';
                html.style.margin = '0';
                html.style.padding = '0';
                let body = document.getElementsByTagName('body')[0];
                body.style.height = '100%';
                body.style.width = '100%';
                body.style.margin = '0';
                body.style.padding = '0';
                body.style.background = 'lightblue';
            }
            
            /**
             * @brief 胜负检测
             * @param 棋局数组
             * @retval true/false
            */
            toCheckWin(pieces)
            {
                let count_tie = 0;
                for(let r=0;r<6;r++)
                {
                    for(let i=0;i<this.boardSize;i++)
                    {
                        if((r==3||r==5)&&i==0)
                        {
                            continue;
                        }
                        else
                        {
                            let flagLeft = false;// 左标记
                            let flagRight = false;// 右标记
                            let flagWhich = 0;// 当前（计数器）记录棋种标记
                            let count = 0;// 计数器
                            //-- 等效列
                            for(let j=0;j<this.boardSize;j++)
                            {
                                let posX = (r==0?i:(r==1||r==2?j:(r==3?i+j:(r==4?i-j:14-j))));
                                let posY = (r==0?j:(r==1?i:(r==2?14-i+j:(r==3||r==4?j:i+j))));
                                //-- 兼容斜方向
                                if(posX>this.boardSize-1||posX<0||posY>this.boardSize-1||posY<0)
                                {
                                    break;
                                }
                                else
                                {
                                    //-- 得到当前棋子
                                    let thisPiece = pieces[posX][posY];
                                    
                                    if(thisPiece)
                                    {
                                        count_tie++;
                                    }

                                    //-- 根据flagWhich进行决策
                                    if(thisPiece==flagWhich)
                                    {
                                        if(flagWhich!=0)
                                        {
                                            count++;
                                        }
                                    }
                                    else if(flagWhich==0)
                                    {
                                        if(j==0)
                                        {
                                            flagWhich = thisPiece;
                                            flagLeft = true;
                                            count++;
                                        }
                                        else
                                        {
                                            flagWhich = thisPiece;
                                            flagLeft = false;
                                            count++;
                                        }
                                    }
                                    else
                                    {
                                        //-- 否则进行算分（只是单次算分）
                                        if(thisPiece==0)
                                        {
                                            flagRight = false;
                                        }
                                        else
                                        {
                                            flagRight = true;
                                        }
                                        if(count>=5)
                                        {
                                            if(flagWhich==1)
                                            {
                                                alert('白胜！');
                                                return true;
                                            }
                                            else
                                            {
                                                alert('黑胜！');
                                                return true;
                                            }
                                        }
                                        //-- 状态转移
                                        flagWhich = thisPiece;
                                        flagLeft = thisPiece==0?false:true;
                                        count = 0;
                                        count += thisPiece==0?0:1; 
                                    }
                                }
                            }
                            //-- 处理等效列最后
                            if(flagWhich&&count>=5)
                            {
                                if(flagWhich==1)
                                {
                                    alert('白胜！');
                                }
                                else
                                {
                                    alert('黑胜！');
                                }
                            }
                        }
                    }
                }
                if(count_tie==this.boardSize*this.boardSize)
                {
                    alert('平！');
                    return true;
                }
                else
                {
                    return false;
                }
            }

            /**
             * @brief 将棋子放置棋盘上
             * @param 目标行，目标列
             * @retval 无
            */
            toSetOnePiece(x,y,flagWhich)
            {
                let canvas = document.getElementById('chessboard');
                let ctx = canvas.getContext('2d');
                ctx.beginPath();
                ctx.fillStyle = flagWhich?'#FFFFFF':'#000000';
                ctx.arc(20+40*x,20+40*y,15,0,Math.PI*2,false);
                ctx.fill();
                ctx.closePath();
            }
            
            /**
             * @brief 初始化画布
             * @param 无
             * @retval 无 
            */
            initCanvas()
            {
                let container = document.getElementById('container');
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.textAlign = 'center';
                let canvas = document.getElementById('chessboard');
                canvas.width = 600;
                canvas.height = 600;
                canvas.style.background = 'lightblue';
                canvas.style.marginTop = '3%';
                canvas.style.boxShadow = '#888888 0 0 8px';
            }
        }
    </script>
</head>
<body>
    <div id="container">
        <canvas id="chessboard"></canvas>
    </div>
</body>
</html>